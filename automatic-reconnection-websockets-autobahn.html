<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="//nicolovaligi.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Nicolò Valigi">
  <meta name="description" content="Posts and writings by Nicolò Valigi">


<meta name="keywords" content="backend, python">

  <title>
Automatic reconnection of Websockets in Autobahn -
    Nicolò Valigi
  </title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67820015-1', 'auto');
  ga('send', 'pageview');

</script></head>

<body>
  <aside>
    <div id="user_meta">
      <a href="//nicolovaligi.com">
        <img src="/blog/images/logo_white.jpg" alt="logo">
      </a>
      <h2><a href="//nicolovaligi.com">Nicolò Valigi</a></h2>
      <p>Writing about Software, Robots, and Machine Learning.</p>
      <ul class="links">
        <li><a href="/pages/talks.html">Talks</a></li>
        <li><a href="/pages/robotics-for-developers-tutorial.html">Robotics for developers</a></li>
        <li><a href="/pages/research.html">Research</a></li>
      </ul>

      <ul style="padding-left: 0;
                 margin-left: -5px;
                 list-style: none;
                 text-align: center;">
        <li>
            <a href="https://github.com/nicolov">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
        <li>
            <a href="mailto:nicolo.valigi@gmail.com">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
    </ul>

    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="//nicolovaligi.com">Index</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/tags.html">Tags</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/archives.html">Archives</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="//nicolovaligi.com/automatic-reconnection-websockets-autobahn.html">Automatic reconnection of Websockets in Autobahn</a></h1>
  </div>
  <div class="article_text">
    <p>After years spent fiddling with inferior technologies, web developers finally have a way to do slick and real-time two-way communication between browser and server. This functionality comes in the way of the Websocket API, which is supported in most <a href="http://caniuse.com/#feat=websockets">reasonably modern</a> browsers.</p>
<p>Websockets are not only used within the browser though. Their simple message-based API can be successfully leveraged for communications of all kinds on top of TCP. In the case of Python, multiple libraries are available. Of these, <a href="https://github.com/tavendo/AutobahnPython">AutobahnJS</a> looked the most promising to me due to:</p>
<ul>
<li>support for both Twisted and Python's core <code>asyncio</code>, for future proofing</li>
<li>extensive test suite</li>
<li>great examples and documentation</li>
</ul>
<h2>The basic example</h2>
<p>Getting started with Autobahn is easy with the included <a href="https://github.com/tavendo/AutobahnPython/tree/master/examples/asyncio/websocket/echo">examples</a>. However, this simple setup is not robust due to the very nature of TCP. Dropped connections are not detected until one of the two parties tries to send the message. This is usually not an issue for browser use, since the user would frequently refresh the page relatively frequently anyway.</p>
<p>On the other hand, server-to-server communication requires better handling of unstable connections. In the following sections, we will look at ways to make Websockets more resilient and re-estabilish the connection in case of problems.</p>
<h2>Pinging to detect broken connections</h2>
<p>In our example setup, the server is available at a fixed IP address and waits for incoming connections from the client. Luckily, the Websocket protocol provides a ping/response mechanism to keep the connection alive (some more information on heartbeat pings is available <a href="http://django-websocket-redis.readthedocs.org/en/latest/heartbeats.html">here</a>).</p>
<p>On the server, we modify the example to set additional protocol options:</p>
<div class="highlight"><pre><span></span>factory = WebSocketServerFactory(debug=False)
factory.protocol = MyServerProtocol
# enable automatic pinging
factory.setProtocolOptions(autoPingInterval=5,
                           autoPingTimeout=2)
</pre></div>
<p>With this change, the server will detect a dropped connection after at most 5+2 seconds, i.e. once the ping timeout is over.</p>
<p>At this stage, the client is still unable to detect dropped connections until it tries to send a message. To solve the problem, we add logic to keep track of the time elapsed since the last ping request. This functionality is implemented as additional methods in the <code>WebSocketClientProtocol</code> subclass, as follows:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">autobahn.asyncio.websocket</span> <span class="kn">import</span> <span class="n">WebSocketClientProtocol</span><span class="p">,</span> \
<span class="n">WebSocketClientFactory</span>

<span class="k">class</span> <span class="nc">MyClientProtocol</span><span class="p">(</span><span class="n">WebSocketClientProtocol</span><span class="p">):</span>
    <span class="n">KEEPALIVE_INTERVAL</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">check_keepalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">last_interval</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_ping_time</span>

        <span class="k">if</span> <span class="n">last_interval</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">PING_INTERVAL</span><span class="p">:</span>
            <span class="c1"># drop connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropConnection</span><span class="p">(</span><span class="n">abort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># reschedule next check</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schedule_keepalive</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">schedule_keepalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Store the future in the class to cancel it later. """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepalive_fut</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PING_INTERVAL</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">check_keepalive</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">onOpen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Start scheduling the keepalive check. """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_ping_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schedule_keepalive</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">onPing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
        <span class="sd">""" Respond to the ping request. """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_ping_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendPong</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="sd">""" Cancel the scheduled future. """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepalive_fut</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre></div>
<h2>Automatic reconnection</h2>
<p>Thanks to the automatic ping, both client and server will detect dropped connections in a timely manner and close the connection. However, we would still like the client to try to reconnect indefinitely. First, we modify the <code>connection_lost</code> method to stop the event loop:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">MyClientProtocol</span>(<span class="n">WebSocketClientProtocol</span>):
    <span class="c c-Singleline"># ...</span>

    <span class="n">def</span> <span class="n">connection_lost</span>(<span class="k">self</span>, <span class="n">exc</span>):
        <span class="s">""" Cancel the future and stop the event loop. """</span>
        <span class="k">self</span>.<span class="n">keepalive_fut</span>.<span class="n">cancel</span>()
        <span class="k">loop</span>.<span class="n">stop</span>()
</pre></div>
<p>We also add a <code>while True:</code> loop in the main code of the module, with a timeout to account for dropped packets during the initial connection:</p>
<div class="highlight"><pre><span></span>while True:
    fut = loop.create_connection(factory, address, port)

    try:
        transport, protocol = loop.run_until_complete(
                                        asyncio.wait_for(fut, 5))
    except asyncio.TimeoutError:
        continue

    loop.run_forever()

    # a little timeout before trying again
    loop.run_until_complete(asyncio.sleep(5))

loop.close()
</pre></div>
<h2>Simulating dropped connections</h2>
<p>Disconnecting the Ethernet cable to simulate dropped connections gets boring very quickly (especially with servers on the cloud..) Use these <code>iptables</code> commands to start dropping all packets exchanged with <code>$SERVER_IP</code>:</p>
<div class="highlight"><pre><span></span><span class="x">iptables -A INPUT -s </span><span class="p">$</span><span class="nv">SERVER_IP</span><span class="x"> -j DROP;</span>
<span class="x">iptables -A OUTPUT -d </span><span class="p">$</span><span class="nv">SERVER_IP</span><span class="x"> -j DROP</span>
</pre></div>
<p>and this one to get rid of the filter when done:</p>
<div class="highlight"><pre><span></span><span class="x">iptables -D INPUT -s </span><span class="p">$</span><span class="nv">SERVER_IP</span><span class="x"> -j DROP;</span>
<span class="x">iptables -D OUTPUT -d </span><span class="p">$</span><span class="nv">SERVER_IP</span><span class="x"> -j DROP</span>
</pre></div>
<h2>Conclusions</h2>
<p>We have seen how to set up keepalive pings in the Python Autobahn Websocket library to quickly detect dropped connections and close them. With a little addition of code and some familiarity with Python's <code>asyncio</code> event loop, the client will also be able to re-estabilish dropped connections to the server.</p>
  </div>
  <div class="article_meta">
    <p>Posted on: lun 10 agosto 2015</p>
    <p>Category: <a href="//nicolovaligi.com/category/2015.html">2015</a>
 &ndash; Tags:
      <a href="//nicolovaligi.com/tag/backend.html">backend</a>,      <a href="//nicolovaligi.com/tag/python.html">python</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Nicolò Valigi. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme originally by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>