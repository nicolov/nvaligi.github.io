<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Nicolò Valigi</title><link href="/" rel="alternate"></link><link href="/feeds/programming.atom.xml" rel="self"></link><id>/</id><updated>2015-09-26T00:00:00+02:00</updated><entry><title>Using (React) Bootstrap components in Reagent</title><link href="/boostrap-components-reagent-clojurescript.html" rel="alternate"></link><published>2015-09-26T00:00:00+02:00</published><author><name>Nicolò Valigi</name></author><id>tag:,2015-09-26:boostrap-components-reagent-clojurescript.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;h2&gt;ClojureScript and Reagent&lt;/h2&gt;
&lt;p&gt;ClojureScript builds on the solid foundations of Clojure to make frontend web development straightforward and fun. Besides, functional concepts in CLJS are a very good match for React's vision of components and immutability.&lt;/p&gt;
&lt;p&gt;If you want to use React as a view layer in ClojureScript, you will need either of two projects: OM and Reagent. While OM seems to be the better known of the two (among the others, used by CircleCI for their web-app), its API retains much of React's verbosity. For a more elaborate comparison, take a look &lt;a href="http://theatticlight.net/posts/Om-and-Reagent/"&gt;here&lt;/a&gt;. All things considered, I like &lt;strong&gt;Reagent&lt;/strong&gt; better and decided it warranted some experimentation time.&lt;/p&gt;
&lt;h2&gt;The problem&lt;/h2&gt;
&lt;p&gt;These days, Bootstrap components are the bread and butter of rapid web prototyping, and life's hard without them, even in Reagent. Unfortunately, while OM has its &lt;a href="https://github.com/racehub/om-bootstrap"&gt;own library&lt;/a&gt; of components, no such convenience exists for Reagent.&lt;/p&gt;
&lt;p&gt;On the other hand, we can easily wrap the &lt;a href="https://react-bootstrap.github.io/"&gt;react-bootstrap&lt;/a&gt; project and have access to all the goodies.&lt;/p&gt;
&lt;h2&gt;Using Bootstrap components&lt;/h2&gt;
&lt;p&gt;First, we add the CLJSJS dependency to the project. I'm using Leiningen, so it's just a matter of editing the &lt;code&gt;project.clj&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(defproject demo-proj "0.1.0"
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/clojurescript "0.0-3211"]
                 [reagent "0.5.0"]
                 [cljsjs/react-bootstrap "0.25.1-0"]]
  ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Going to the views files, we require the React Bootstrap namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ns demo-project.views
    (:require [reagent.core :as reagent]
              [cljsjs.react-bootstrap]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We then use the magic &lt;code&gt;adapt-react-class&lt;/code&gt; method (&lt;a href="https://reagent-project.github.io/news/news050.html"&gt;reference&lt;/a&gt;) to convert a React component to a Reagent-flavoured one that can be used directly:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(def Button (reagent/adapt-react-class (aget js/ReactBootstrap "Button")))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Button&lt;/code&gt; component is now ready to use within the Hiccup templates:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[:div
  [:h2 "A sample title"]
  [Button "with a button"]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;We have seen how to take advantage of the vast amount of community-contributed React components and use them whithin a Reagent application without much effort.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</summary></entry><entry><title>Review of the CS61AS programming MOOC on EdX Edge</title><link href="/cs61as-programming-mooc-review.html" rel="alternate"></link><published>2015-09-16T00:00:00+02:00</published><author><name>Nicolò Valigi</name></author><id>tag:,2015-09-16:cs61as-programming-mooc-review.html</id><summary type="html">&lt;html&gt;&lt;body&gt;&lt;p&gt;With the recent upsurge in the cachet of functional programming, your average self-taught developer will find himself in lack (real of perceived) of fundamental computer science concepts. For this reason, I've recently worked through the EdX Edge course based on Berkeley's CS61AS introductory computer science course. I've already published the homework solutions on &lt;a href="https://github.com/nicolov/cs61as-racket-homework"&gt;GitHub&lt;/a&gt; and this is my short review of the course itself.&lt;/p&gt;
&lt;h2&gt;The course&lt;/h2&gt;
&lt;p&gt;The course is basically a tutored, watered-down version of the famous book "Structure and Interpretation of Computer Programs", by Abelson and Sussman. A fair part of the exercises is taken straight from SICP, together with some additional coursework by the authors.&lt;/p&gt;
&lt;p&gt;The material is based on a didactic dialect of LISP (Simply Scheme) but isn't overly focused on language details. Besides, LISPs don't have much syntax to begin with. I've done the exercises using Racket and only had to adapt a few idioms. You could probably use the homework as a nice and gentle introduction to LISP-like languages.&lt;/p&gt;
&lt;h2&gt;Content&lt;/h2&gt;
&lt;p&gt;The first chapters will definitely be boring if you have already worked through some other functional programming material. On the other hand, the presentation of trees and other data structures was straight to the point and helped reinforced by useful exercises.&lt;/p&gt;
&lt;p&gt;Mutation and state management are important topics in today's world of concurrent programming. The course doesn't disappoint in this respect, offering thoughtful materials and exercises about implementing data structures with mutable lists and handling the ripercussions of mutability.&lt;/p&gt;
&lt;p&gt;The course also gets you to implement your own object oriented constructs by way of closures and other core concepts. After the initial enlightenment, that chapter got fairly boring as most experienced developers are already familiar with the ideas of message passing and internal object state.&lt;/p&gt;
&lt;p&gt;The final chapters about streams and interpreters were the most challenging and mind-bending of all, probably because these ideas don't appear very often in your average web dev's workday. If nothing, I'd definitely recommend joining the course for those chapters alone. &lt;/p&gt;
&lt;h2&gt;Exercises&lt;/h2&gt;
&lt;p&gt;As mentioned above, the course contains a selection of exercises from SICP, making it easier to make your way through an otherwise intimidating book. The progression is nicely graded, guiding you through harder and harder excercises.&lt;/p&gt;
&lt;p&gt;I've managed to implement most of the homework in Racket instead of Scheme, as I felt it was an easier environment to set up on the Mac.&lt;/p&gt;
&lt;h2&gt;Final verdict&lt;/h2&gt;
&lt;p&gt;The course lives up to its reputation and offers a great theoretical grouding for self-taught developers. I would suggest skipping straight to units 3 and 4 to deal with the juicier concepts.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</summary></entry></feed>