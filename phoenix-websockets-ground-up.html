<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="http://nicolovaligi.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="http://nicolovaligi.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="http://nicolovaligi.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Nicolò Valigi">
  <meta name="description" content="Posts and writings by Nicolò Valigi">


<meta name="keywords" content="backend, elixir, phoenix">

  <title>
Phoenix WebSockets from the ground up -
    Nicolò Valigi
  </title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67820015-1', 'auto');
  ga('send', 'pageview');

</script></head>

<body>
  <aside>
    <div id="user_meta">
      <a href="http://nicolovaligi.com">
        <img src="/blog/images/logo_white.jpg" alt="logo">
      </a>
      <h2><a href="http://nicolovaligi.com">Nicolò Valigi</a></h2>
      <p>Chronicles of learning.</p>
      <ul class="links">
        <li><a href="http://nicolovaligi.com/pages/tutorial-on-robotics-for-developers.html">Tutorial on robotics for developers</a></li>
      </ul>

      <ul style="padding-left: 0;
                 margin-left: -5px;
                 list-style: none;
                 text-align: center;">
        <li>
            <a href="https://github.com/nicolov">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
        <li>
            <a href="mailto:nicolo.valigi@gmail.com">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
    </ul>

    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="http://nicolovaligi.com">Index</a> &nbsp; &brvbar; &nbsp;
      <a href="http://nicolovaligi.com/tags.html">Tags</a> &nbsp; &brvbar; &nbsp;
      <a href="http://nicolovaligi.com/archives.html">Archives</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="http://nicolovaligi.com/phoenix-websockets-ground-up.html">Phoenix WebSockets from the ground up</a></h1>
  </div>
  <div class="article_text">
    <p>Inspired by the <a href="http://youtube.com/watch?v=IDKCSheBc-8">Phoenix is not your
application</a> presentation, I dug into
Phoenix's internals to investigate how to use a custom WebSockets protocol
while retaining the well-thought abstractions and patterns.  I'm especially
referring to Phoenix's solid pubsub backends, integration with the Cowboy HTTP
server, and configuration/logging handling.</p>
<p>I was surprised to see that the code involved is very small and readable, with
the exception of some magic patterns to shuffle between various shapes of
return values, GenServer state changes, and the like. On the bright side, such
code would have been hair-pulling to implement in a language without pattern
matching.</p>
<p>What follows is a log of my journey through the code base, and all the moving
pieces that come together for Phoenix's awesome WebSockets support.</p>
<h2>Configuration</h2>
<p>First, we take a <em>top down</em> look at how a Phoenix application is configured to
handle WebSockets, starting from the user-provided entry point and reaching
the configuration of the Cowboy HTTP server.</p>
<h3>Endpoint (phoenix/endpoint.ex)</h3>
<p>Your application's endpoint will use <code>Phoenix.Endpoint</code> and have one or more calls to
its <code>socket</code> macro to set up the URLs that will be handling websockets. The <code>socket</code>
macro accumulates socket information in the <code>@phoenix_sockets</code> attribute:</p>
<div class="highlight"><pre><span></span><span class="kd">defmacro</span> <span class="n">socket</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">quote</span> <span class="k">do</span>
        <span class="na">@phoenix_sockets</span> <span class="p">{</span><span class="k">unquote</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="k">unquote</span><span class="p">(</span><span class="n">module</span><span class="p">)}</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
<p>and the <code>__before_compile__</code> macro creates a function that returns that
attribute itself:</p>
<div class="highlight"><pre><span></span><span class="kd">defmacro</span> <span class="n">__before_compile__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sockets</span> <span class="o">=</span> <span class="nc">Module</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="ss">:phoenix_sockets</span><span class="p">)</span>

    <span class="k">quote</span> <span class="k">do</span>
        <span class="kd">def</span> <span class="n">__sockets__</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="k">unquote</span><span class="p">(</span><span class="n">sockets</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
<p>The <code>Endpoint</code> also starts the <code>Adapter</code> supervision loop:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="nc">Adapter</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="na">@otp_app</span><span class="p">,</span> <span class="bp">__MODULE__</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
<h3>Adapter (phoenix/endpoint/adapter.ex)</h3>
<p>The supervisor tree includes a <code>Phoenix.Endpoint.Server</code> supervisor, that
we're going to look at next.</p>
<h3>Endpoint.Server (phoenix/endpoint/server.ex)</h3>
<p>Calls back to the <code>CowboyHandler</code> and starts supervising the <code>child_spec</code> it returns.</p>
<h3>Endpoint.CowboyHandler</h3>
<p>The <code>child_spec</code> function looks at the sockets defined in the <code>Endpoint</code>. It
looks up the corresponding transport for each one and passes the bunch to the
<code>Plug.Adapters.Cowboy</code> Cowboy adapter.</p>
<h2>Communication</h2>
<p>This section traces the flow of data arriving as a WebSockets message as it
bubbles up towards the application logic the developer has implemented. This
will take a <em>bottom-up</em> perspective, from the Cowboy handler to the user-
provided callbacks.</p>
<h3>Endpoint.CowboyWebSocket</h3>
<p>When incoming messages arrive on the wire, Cowboy calls the appropriate functions on the
<code>CowboyWebSocket</code> module. In turn, these pass the payload up to the
corresponding function in the <code>Transports.WebSocket</code> module, such as:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">websocket_handle</span><span class="p">({</span><span class="n">opcode</span> <span class="o">=</span> <span class="ss">:text</span><span class="p">,</span> <span class="n">payload</span><span class="p">},</span> <span class="n">req</span><span class="p">,</span> <span class="p">{</span><span class="n">handler</span><span class="p">,</span> <span class="n">state</span><span class="p">})</span> <span class="k">do</span>
    <span class="n">handle_reply</span> <span class="n">req</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">handler</span><span class="o">.</span><span class="n">ws_handle</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
<h3>Transport.WebSocket</h3>
<p><code>Transport.WebSocket</code> implements the <code>Socket.Transport</code> behaviour and uses many convenience functions defined there to handle connection, disconnection, serialization, and deserialization. In a sense, it acts as a middleman between the socket and the channel, shuffling messages back and forth when appropriate.</p>
<p>On <em>connection</em>, <code>Transports.WebSocket</code> calls back to the <code>connect</code> function
in <code>Socket.Transport</code>. After setting up a new <code>Socket</code> struct that will be
kept as part of the process state, that function calls back the <code>connect</code>
function in the user-defined module to handle authentication.</p>
<p><em>Incoming messages</em> (<code>ws_handle</code>), are dispatched to the right channel using the <code>Socket.Transport.dispatch</code> function, that figures out the right channel by looking at the <code>HashDict</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">dispatch</span><span class="p">(%</span><span class="nc">Message</span><span class="p">{}</span> <span class="o">=</span> <span class="n">msg</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">channels</span>
    <span class="o">|&gt;</span> <span class="nc">HashDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">topic</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">do_dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
<p>and then actually sends the payload to the <code>Channel</code> process:</p>
<div class="highlight"><pre><span></span><span class="kd">defp</span> <span class="n">do_dispatch</span><span class="p">(</span><span class="n">channel_pid</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">_socket</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">send</span><span class="p">(</span><span class="n">channel_pid</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="ss">:noreply</span>
<span class="k">end</span>
</pre></div>
<p>Especially interesting is the <code>dispatch</code> function that handles new topic topic
subscriptions, with signature:</p>
<div class="highlight"><pre><span></span><span class="kd">defp</span> <span class="n">do_dispatch</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="p">%{</span><span class="ss">event</span><span class="p">:</span> <span class="s2">"phx_join"</span><span class="p">,</span> <span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">}</span> <span class="o">=</span> <span class="n">msg</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
</pre></div>
<p>that checks whether the user has defined a channel corresponding to the
current topic,</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">__channel__</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">transport_name</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="p">%</span><span class="nc">Socket</span><span class="p">{</span><span class="n">socket</span> <span class="o">|</span> <span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">channel</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
</pre></div>
<p>has the <code>Socket</code> <code>join</code> it,</p>
<div class="highlight"><pre><span></span><span class="nc">Phoenix.Channel.Server</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
<p>and replies positively to the client:</p>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="ss">:joined</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">%</span><span class="nc">Reply</span><span class="p">{</span><span class="ss">ref</span><span class="p">:</span> <span class="n">msg</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">status</span><span class="p">:</span> <span class="ss">:ok</span><span class="p">,</span> <span class="ss">payload</span><span class="p">:</span> <span class="n">response</span><span class="p">}}</span>
</pre></div>
<h3>Channel.Server</h3>
<p>As the <code>Channel</code> module itself is only a behaviour that user code needs to
adhere to, most of the actual functionality is implemented in the Genserver at
<code>Channel.Server</code>. Each new socket connection causes a new <code>Channel.Server</code> to
be spun up. Precisely, it's the transport that calls the <code>join</code> function in
the <code>Channel.Server</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">join</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">auth_payload</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">make_ref</span><span class="p">()</span>
    <span class="k">case</span> <span class="nc">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">{</span><span class="n">socket</span><span class="p">,</span> <span class="n">auth_payload</span><span class="p">,</span> <span class="n">self</span><span class="p">(),</span> <span class="n">ref</span><span class="p">})</span> <span class="k">do</span>
</pre></div>
<p>in the <code>init</code> GenServer callback, the channel asks the <code>Pubsub.Server</code> to
subscribe to its topic:</p>
<div class="highlight"><pre><span></span><span class="nc">PubSub</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">pubsub_server</span><span class="p">,</span> <span class="n">self</span><span class="p">(),</span> <span class="n">socket</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
</pre></div>
<p>and then messages itself back the result of the subscription, so that it can
handle messages.</p>
<p>Broadcasts are sent through the pubsub server:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">pubsub_server</span><span class="p">,</span> <span class="n">topic</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">PubSub</span><span class="o">.</span><span class="n">broadcast</span> <span class="n">pubsub_server</span><span class="p">,</span> <span class="n">topic</span><span class="p">,</span> <span class="p">%</span><span class="nc">Broadcast</span><span class="p">{</span>
      <span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">,</span>
      <span class="ss">event</span><span class="p">:</span> <span class="n">event</span><span class="p">,</span>
      <span class="ss">payload</span><span class="p">:</span> <span class="n">payload</span>
    <span class="p">}</span>
<span class="k">end</span>
</pre></div>
<p>Finally, messages received from the pubsub server are handled by the user's
application logic implemented in the channel's <code>handle_in</code> function:</p>
<div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">handle_info</span><span class="p">(%</span><span class="nc">Message</span><span class="p">{</span><span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">event</span><span class="p">:</span> <span class="n">event</span><span class="p">,</span> <span class="ss">payload</span><span class="p">:</span> <span class="n">payload</span><span class="p">,</span> <span class="ss">ref</span><span class="p">:</span> <span class="n">ref</span><span class="p">},</span>
                <span class="p">%{</span><span class="ss">topic</span><span class="p">:</span> <span class="n">topic</span><span class="p">}</span> <span class="o">=</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">event</span>
    <span class="o">|&gt;</span> <span class="n">socket</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">handle_in</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">put_in</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
    <span class="o">|&gt;</span> <span class="n">handle_result</span><span class="p">(</span><span class="ss">:handle_in</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
<h2>Conclusions</h2>
<p>While well thought-out, the internals are pretty tightly coupled to the topic-
based nature of Phoenix's WS protocol. Transports, channels, and the pubsub
server all operate by switching messages based on their topic. While flexibile
enough for most clean-slate real time applications, this choice makes it
somewhat hard to retro-fit an existing protocol without overhauling
significant parts of the stack.</p>
  </div>
  <div class="article_meta">
    <p>Posted on: Tue 31 May 2016</p>
    <p>Category: <a href="http://nicolovaligi.com/category/2016.html">2016</a>
 &ndash; Tags:
      <a href="http://nicolovaligi.com/tag/backend.html">backend</a>,      <a href="http://nicolovaligi.com/tag/elixir.html">elixir</a>,      <a href="http://nicolovaligi.com/tag/phoenix.html">phoenix</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Nicolò Valigi. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme originally by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>