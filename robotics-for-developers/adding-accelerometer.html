<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="//nicolovaligi.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Nicolò Valigi">
  <meta name="description" content="Posts and writings by Nicolò Valigi">


<meta name="keywords" content="robotics, perception">

  <title>
Robotics for developers 6/6: adding an accelerometer -
    Nicolò Valigi
  </title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67820015-1', 'auto');
  ga('send', 'pageview');

</script></head>

<body>
  <aside>
    <div id="user_meta">
      <a href="//nicolovaligi.com">
        <img src="/blog/images/logo_white.jpg" alt="logo">
      </a>
      <h2><a href="//nicolovaligi.com">Nicolò Valigi</a></h2>
      <p>Chronicles of learning.</p>
      <ul class="links">
        <li><a href="//nicolovaligi.com/pages/tutorial-on-robotics-for-developers.html">Tutorial on robotics for developers</a></li>
      </ul>

      <ul style="padding-left: 0;
                 margin-left: -5px;
                 list-style: none;
                 text-align: center;">
        <li>
            <a href="https://github.com/nicolov">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
        <li>
            <a href="mailto:nicolo.valigi@gmail.com">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>
    </ul>

    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="//nicolovaligi.com">Index</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/tags.html">Tags</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/archives.html">Archives</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="//nicolovaligi.com/robotics-for-developers/adding-accelerometer.html">Robotics for developers 6/6: adding an accelerometer</a></h1>
  </div>
  <div class="article_text">
    <p>In a <a href="//nicolovaligi.com/robotics-for-developers/tracking-over-time.html">previous post</a> we added multiple camera states to track the robot's movement over time. In that configuration, however, localization data is only available when a marker is captured by the camera. In this post, we'll see how adding a new sensor source can help the system localize the robot for brief periods of time even when no marker is visible.</p>
<h2>Using IMUs for navigation</h2>
<p>An inertial measurement unit (IMUs) is a mechanical device that can measure its acceleration and angular velocity. By mounting one of these sensors on a robot, the SLAM system gains valuable information about motion, that can be used to improve localization accuracy.</p>
<p>While there are several kinds of IMUs on the market, most robotic applications use so-called MEMS IMUs, due to their small size and limited weight. These devices include two different components: an accelerometer (to measure acceleration) and a gyroscope (to measure angular velocity).</p>
<p><img alt="A $10 IMU board" class="img-center" src="//nicolovaligi.com/robotics-for-developers/mpu6050.jpg" style="max-width: 300px"/></p>
<p>Unfortunately, IMUs can not be used directly for navigation, since they don't measure position or orientation, but rather their <em>time derivatives</em> (second derivative in the case of the accelerometer, and first in the case of the gyroscope). Calculus tells us that we would need to <strong>integrate</strong> the sensor data to compute the robot position and orientation. However, this operation is strongly sensitive to noise, since any small error in the derivatives will grow unbounded over time. In real applications, such sensitivity shows up as <em>divergence</em> of the localization estimate. That's the reason why drones constantly require GPS reception or cameras to stabilize themselves, as the onboard sensors are useless after 20-30 seconds.</p>
<p>It turns out that not all hope is lost. IMUs and vision data are nicely <em>complementary</em> sources. IMUs offer much higher data rate (~200Hz vs ~20Hz) but drift over time. Processing image data requires more processing power than integrating the IMU measurements, but can stabilize the system over time.</p>
<p>For these reasons, we will be integrating IMU measurements into the SLAM optimization implemented in the previous posts. We'll see how the IMU can provide reasonably good location estimates even when no markers are visible in the camera frame for brief periods (~5 seconds). Furthermore, the IMU will also allow us to reduce the camera frame rate (and thus the processing load) while retaining access to a high-frequency navigation-solution.</p>
<h2>Adding IMUs to the localization problem</h2>
<p>Using IMUs for SLAM is quite involved, since many of the measurements and states and correlated by a non-trivial measurement model. Luckily, GTSAM comes with a powerful factor to handle sensor data from an IMU, implemented according to <a href="www.roboticsproceedings.org/rss11/p06.pdf">this paper</a>. Due to Physics, the IMU factor is slightly more involved than the other factors we have used.</p>
<p>Until now, the estimation has only concerned the camera frame, that we identified with the robot position in the world. However, now that we introduced an IMU as well, we'll need to distinguish between a <em>camera frame</em> (that observes the marker) and the <em>body frame</em> (location of the IMU). The transformation between these two frames can either be measured beforehand using a ruler, calibrated offline, or estimated online as part of the localization process. We'll be using the second approach, since the datasets already come with the calibration data.</p>
<p>From the estimation point of view, the IMU factor constrains successive positions and orientations in time. The gyroscope directly measures angular velocity, so that it can directly be used to constrain two successive orientation states (the math is a bit hairy though, as it uses incremental rotations). The acceleration as measured by the accelerometer, however, can not be used directly, since it's the second derivative. To handle this, we also need to keep the <em>velocity</em> of the robot as part of the estimation states.</p>
<p>We need one final change, due to the way that accelerometers and gyroscope work. In real life, their measurements are not exact, but are <em>biased</em>. This can be modeled by adding a pair 3-dimensional bias terms to the measurement models of the IMU. The bias will be different each time the sensor is turned on, so it can not easily be calibrated out, but will change rather slowly over time. This means we can easily estimate the two biases as part of the estimation process.</p>
<p>To recap, the IMU factor will be connected to a variety of states: the previous and current poses (position + orientation), the current pair of biases, and the current and previous velocities. That's how it looks like in code:</p>
<div class="highlight"><pre><span></span>    <span class="n">graph_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">gtsam</span><span class="o">::</span><span class="n">ImuFactor</span><span class="p">(</span><span class="n">s_prev_ic</span><span class="p">,</span> <span class="n">s_prev_vel</span><span class="p">,</span>
                         <span class="n">s_ic</span><span class="p">,</span> <span class="n">s_vel</span><span class="p">,</span> <span class="n">s_bias</span><span class="p">,</span>
                         <span class="n">pre_integr_data</span><span class="p">));</span>
</pre></div>
<p>Note that the implementation in GTSAM has the concept of <em>IMU preintegration</em>, i.e. accumulates a packet of measurements and adds multiple ones in a single factor (the paper linked above has more details). This reduces the size of the graph and thus the computational load, since we can keep adding pose states at camera frame rate, rather than the much higher IMU rate.</p>
<p>As explained above, the pair of biases is modeled as a random walk, and we thus also need to add a simple <code>BetweenFactor</code> to model their time evolution. Following the concept of a random walk, we expect the change in biases to be zero. The noise model for this factor depends on the quality of the sensor and can be calibrated or extracted from its datasheet.</p>
<div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">bias_between_noise</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">::</span><span class="n">noiseModel</span><span class="o">::</span><span class="n">Diagonal</span><span class="o">::</span><span class="n">Sigmas</span><span class="p">(</span>
        <span class="n">sqrt</span><span class="p">(</span><span class="n">pre_integr_data</span><span class="p">.</span><span class="n">deltaTij</span><span class="p">())</span> <span class="o">*</span> <span class="n">bias_between_sigmas_vec_</span><span class="p">);</span>

<span class="n">graph_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">gtsam</span><span class="o">::</span><span class="n">BetweenFactor</span><span class="o">&lt;</span><span class="n">gtsam</span><span class="o">::</span><span class="n">imuBias</span><span class="o">::</span><span class="n">ConstantBias</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">s_prev_bias</span><span class="p">,</span> <span class="n">s_bias</span><span class="p">,</span>
        <span class="n">gtsam</span><span class="o">::</span><span class="n">imuBias</span><span class="o">::</span><span class="n">ConstantBias</span><span class="p">(),</span> <span class="n">bias_between_noise</span><span class="p">);</span>
</pre></div>
<h2>Gravity and initial calibration</h2>
<p>One detail I've glossed over above is the initialization of an IMU-based system. Since the sensing elements of accelerometers are subject to gravitational acceleration (just like any other body on the surface of Earth), the values they measure include a gravitational acceleration term.</p>
<p>Obviously, this term must be accounted for in the measurement model. According to ROS conventions, we use a navigation frame with upwards Z axis, and inform the factor of such:</p>
<div class="highlight"><pre><span></span><span class="n">preint_params_</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">::</span><span class="n">PreintegrationParams</span><span class="o">::</span><span class="n">MakeSharedU</span><span class="p">(</span><span class="mf">9.81</span><span class="p">);</span>
</pre></div>
<p>To make sure that the system works properly, it's important that the <em>initial body orientation</em> is coherent with the gravity direction. In most applications, it can be safely be assumed that the robot is initially stationary. Under this assumption of zero motion, the accelerometer only measures gravitational acceleration. This means that a good estimate of the initial orientation can be found by requiring that the measured gravity vector transformed to the world frame through the initial pose matches the upwards direction. That's what we do in the <code>do_accel_init</code> function:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">do_accel_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">gtsam</span><span class="o">::</span><span class="n">Vector3</span> <span class="n">acc_avg</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">kv</span> <span class="p">:</span> <span class="n">imu_meas_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">acc_avg</span> <span class="o">+=</span> <span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">acc_avg</span> <span class="o">/=</span> <span class="n">imu_meas_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">ROS_WARN_STREAM</span><span class="p">(</span><span class="s">"Gravity-aligning with accel. vector:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">acc_avg</span><span class="p">);</span>

    <span class="n">gtsam</span><span class="o">::</span><span class="n">Vector3</span> <span class="n">gravity_vec</span><span class="p">;</span>
    <span class="n">gravity_vec</span> <span class="o">&lt;&lt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gravity_magn_</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">initial_att</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">::</span><span class="n">Rot3</span><span class="p">(</span>
        <span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="p">().</span><span class="n">setFromTwoVectors</span><span class="p">(</span><span class="n">acc_avg</span><span class="p">,</span> <span class="n">gravity_vec</span><span class="p">));</span>
    <span class="n">initial_pose_</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">::</span><span class="n">Pose3</span><span class="p">(</span><span class="n">initial_att</span><span class="p">,</span> <span class="n">gtsam</span><span class="o">::</span><span class="n">Point3</span><span class="p">());</span>

    <span class="p">(</span><span class="n">initial_pose_</span> <span class="o">*</span> <span class="n">acc_avg</span><span class="p">).</span><span class="n">print</span><span class="p">(</span><span class="s">"Gravity vector after alignment:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">accel_init_done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>Localization without markers</h2>
<p>To show that the IMU really improves performance, we can artificially disable marker tracking for a few seconds and compare the pose <em>predicted</em> using the IMU to the one computed by marker tracking. This trick simulates a tracking failure and will ensure that the biases have converged and that the coordinate transformations are correct.</p>
<p>The following plots compare the prediction to the final estimate after optimization. You can see how the two tracks of values are pretty close, since the fiducial marker is tracked at 20Hz and the IMU measurements don't have time to diverge. The section without data points in the middle is the artificial pause.</p>
<iframe frameborder="0" height="500" scrolling="no" src="https://plot.ly/~nikoperugia/29.embed" width="600"></iframe>
<iframe frameborder="0" height="500" scrolling="no" src="https://plot.ly/~nikoperugia/27.embed" width="600"></iframe>
<p>The most important point is the one right after marker tracking resumes. You can see how the gyroscopes are incredibily accurate, and the rotation estimate agrees almost perfectly with the vision estimate. Accelerometers are less precise, but their estimate is still good.</p>
<h2>Bias estimation</h2>
<p>As mentioned above, correct modeling of IMU errors requires online estimation of accelerometer and gyroscope biases. To double-check that everything is working correctly, we look at the evolution of one component of the bias over time:</p>
<iframe frameborder="0" height="500" scrolling="no" src="https://plot.ly/~nikoperugia/25.embed" width="600"></iframe>
<p>The bias hovers around a very small value, showing that the constraints from the markers are enough to estimate it. This fact is part of the broader topic of <strong>observability analysis</strong>, which analyzes which states of a system can be <em>observed</em> given a certain set of sensors.</p>
<h2>Conclusions</h2>
<p>We have seen how adding an IMU can make the SLAM system more robust to missing visual information and potentially reduce the computational load. Since these sensors are cheap and light, they're now a staple of state estimation in drones and all sort of gadgets, including Google Tango.</p>
  </div>
  <div class="article_meta">
    <p>Posted on: Thu 25 August 2016</p>
    <p>Category: <a href="//nicolovaligi.com/category/6_imu.html">6_imu</a>
 &ndash; Tags:
      <a href="//nicolovaligi.com/tag/robotics.html">robotics</a>,      <a href="//nicolovaligi.com/tag/perception.html">perception</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Nicolò Valigi. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme originally by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>