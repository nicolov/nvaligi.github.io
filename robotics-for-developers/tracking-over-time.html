<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="//nicolovaligi.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="//nicolovaligi.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Nicolò Valigi">
  <meta name="description" content="Posts and writings by Nicolò Valigi">

  <link href="//nicolovaligi.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Nicolò Valigi Atom" />

<meta name="keywords" content="robotics, perception">

  <title>
Robotics for developers 4/6: tracking the robot over time -
    Nicolò Valigi
  </title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67820015-1', 'auto');
  ga('send', 'pageview');

</script></head>

<body>
  <aside>
    <div id="user_meta">
      <a href="//nicolovaligi.com">
        <img src="/blog/images/logo_white.jpg" alt="logo">
      </a>
      <h2><a href="//nicolovaligi.com">Nicolò Valigi</a></h2>
      <p>Writing about Software, Robots, and Machine Learning.</p>
      <ul class="links">
        <li><a href="/pages/talks.html">Talks</a></li>
        <li><a href="/pages/robotics-for-developers-tutorial.html">Robotics for developers</a></li>
        <li><a href="/pages/research.html">Research</a></li>
        <li><a href="/feeds/all.atom.xml">RSS feed</a></li>
      </ul>

      <ul style="padding-left: 0;
                 margin-left: -5px;
                 list-style: none;
                 text-align: center;">

        <!-- github -->
        <li>
            <a href="https://github.com/nicolov">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>

        <!-- mail -->
        <li>
            <a href="mailto:nicolo.valigi@gmail.com">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>

        <!-- RSS -->
        <li>
            <a href="/feeds/all.atom.xml">
                <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                </span>
            </a>
        </li>

    </ul>

    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="//nicolovaligi.com">Index</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/tags.html">Tags</a> &nbsp; &brvbar; &nbsp;
      <a href="//nicolovaligi.com/archives.html">Archives</a>
      &brvbar; <a href="//nicolovaligi.com/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="//nicolovaligi.com/robotics-for-developers/tracking-over-time.html">Robotics for developers 4/6: tracking the robot over time</a></h1>
  </div>
  <div class="article_text">
    <p>In the previous post, we have set up a probabilistic model to determine the relative position between the onboard camera and an artificial marker placed on the scene. So far, so good. However, this approach considers each frame independently, wihout any notion of continuous motion of the robot.</p>
<p>This simplification is actually surprisingly fine in our case, since fiducial markers can easily be tracked frame-by-frame without issues (that's why we picked them in the first place, after all). However, a real life system will use natural features that need to be tracked continously, and thus needs to somehow remember its history. In the next section, we're going to have a look at the two main ways of doing it.</p>
<h2>Adding more frames</h2>
<p>The most intuitive way to incorporate knowledge of past states in the system is to extend the state each time a new image is captured. The factor graph we had at the end of the last post:</p>
<p><a href="//nicolovaligi.com/robotics-for-developers/2_architecture/fgraph_singlemarker.pdf"><img alt="Single marker factor graph" class="img-center" src="//nicolovaligi.com/__pdf_previews__/robotics-for-developers/2_architecture/fgraph_singlemarker.pdf.png" style="max-width: 320px"/></a></p>
<p>after 2 more frames would look like this instead:</p>
<p><a href="//nicolovaligi.com/robotics-for-developers/4_time_evolution/fgraph_multicam.pdf"><img alt="Factor graph with multiple cameras" class="img-center" src="//nicolovaligi.com/__pdf_previews__/robotics-for-developers/4_time_evolution/fgraph_multicam.pdf.png" style="max-width: 300px"/></a></p>
<p>The state element for the marker pose doesn't need to be duplicated, since we assume that it stands still. However, we consider that each new frame corresponds to a new camera position and thus duplicate the corresponding state element accordingly.</p>
<p>Besides the added camera poses and corresponding marker observations, we had to add a whole new sets on factors (on the right in the graph above). These factors encode the our knowledge that successive camera positions will be rather close to each other (since the robot moves with a relative low velocity). GTSAM offers a <code>BetweenFactor</code> that can be used to constrain the relative pose between two state element. On a ground robot, we could have used data from the wheel sensors to correlate two camera states. In this case, however, we have no such information and will postulate the camera is standing still. Since this is obviously incorrect, we're going to adopt an appropriate noise model so that the optimizer places little faith in this prediction.</p>
<p>In a later post, we're going to replace this rough approximation with information from the accelerometer.</p>
<h2>Smoothing vs filtering</h2>
<p>It's obvious how this approach doesn't scale well at all. Since the state elements need to form a square matrix, the space complexity immediately jumps to <span class="math">\(O(N^2)\)</span>, which is bad enough in itself. What's more, the algorithms needed for actually solving the problem run in <span class="math">\(O(N^3)\)</span>, making this naive approach untenable for real applications. Since we're not discarding any information, this <strong>smoothing</strong> approach is optimal and is proven to recover the MAP estimate as expected.</p>
<p>In the following, we're basically going to ignore these computational considerations and go ahead with dumb smoothing. However, it's important to mention a whole different approach: <strong>filtering</strong>. An example is the well-known <em>Kalman filter</em>, a much faster algorithm that only keeps around one copy of the camera pose at all times. While in the smoothing case, information is spread out over a bigger graph which is only sparsely connected, filtering results in a very small, densely connected graph. <sup id="fnref:why_filter"><a class="footnote-ref" href="#fn:why_filter" rel="footnote">1</a></sup></p>
<p>The simplifications involved in filtering have consequences in accuracy and stability, as a lot of information is thrown away at each step (at least in the general case). As to why I haven't decided to use a Kalman filter for this series, I personally find filtering less intuitive to understand and more of a black art to tweak.</p>
<h2>Implementation</h2>
<p>I'll admit straight away that the "improvement" in the current post does nothing but slow down the system as the state grows bigger and bigger frame after frame. In theory, it should also be slightly more robust when handling degenerate geometric conditions, since informations from neighboring frames can be used to constrain the marker position a bitter. I have not observed much difference in practice though. <sup id="fnref:ambiguity"><a class="footnote-ref" href="#fn:ambiguity" rel="footnote">2</a></sup></p>
<p>However, these changes to the factor graph structure will be useful when observing multiple markers in the same image. That being said, the only implementation difference is the addition of some book-keeping code:</p>
<ul>
<li>
<p>we only add the prior belief to the marker position once, at the first frame,</p>
</li>
<li>
<p>since we're constantly adding new pieces to the state, the optimizer needs initial guesses for these new values. The obvious thing to do here is to initialize newly added states with the MAP obtained at the last step.</p>
</li>
</ul>
<h2>Running time</h2>
<p>As anticipated, the performance is now pathetic, but we can live with that for now knowing that GTSAM also implements more efficient algorithms that can be used with a few lines of code.<sup id="fnref:isam"><a class="footnote-ref" href="#fn:isam" rel="footnote">3</a></sup> I've done some equally pathetic benchmarking, but the trend is clear:</p>
<div>
<a href="https://plot.ly/~nikoperugia/13/" style="display: block; text-align: center;" target="_blank" title="Solve time [s] vs Frame number"><img alt="Solve time [s] vs Frame number" onerror="this.onerror=null;this.src='https://plot.ly/404.png';" src="https://plot.ly/~nikoperugia/13.png" style="max-width: 100%;width: 600px;" width="600"/></a>
<script async="" data-plotly="nikoperugia:13" src="https://plot.ly/embed.js"></script>
</div>
<h2>Next steps</h2>
<p>Next time, we'll build upon the work done here and introduce support for multiple markers visible in the same frame. This will again involve extensions to the state as we observe new markers, but the additional effect on performance will be limited as the total number of possible markers is low.</p>
<h3>Notes</h3>
<div class="footnote">
<hr/>
<ol>
<li id="fn:why_filter">
<p>This <a href="https://www.doc.ic.ac.uk/~ajd/Publications/strasdat_etal_ivc2012.pdf">interesting paper</a> analyzes this issue and depth and presents the case both for and against filtering. It's a good read, together with this <a href="https://www.doc.ic.ac.uk/~ajd/Publications/strasdat_etal_icra2010.pdf">related one</a>. <a class="footnote-backref" href="#fnref:why_filter" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:ambiguity">
<p>Under some conditions, pose recovery from fiducial markers can suffer from ambiguities. This problem manifests itself during the optimization problem. Since there is a second minimum point close to the global minimum, the optimizer may snap back and forth between one and the other. <a class="footnote-backref" href="#fnref:ambiguity" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:isam">
<p>In the smoothing world, there are two main ways to reduce the computational load of larger maps. One is to exploit the sparsity of the problem matrix and use specific algorithms with time complexity lower than <span class="math">\(N^3\)</span>. Instead, GTSAM takes a graph-based approach and identifies which partitions of the factor graph need to be re-evaluated upon each new sensor measurement. <a href="http://frc.ri.cmu.edu/~kaess/pub/Kaess12ijrr.pdf">iSAM2</a> has significant computational advantages compared to the naive approach. Little or no modifications are needed to the problem definition to take advantage of this better solver. <a class="footnote-backref" href="#fnref:isam" rev="footnote" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
</ol>
</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="article_meta">
    <p>Posted on: dom 31 luglio 2016</p>
    <p>Category: <a href="//nicolovaligi.com/category/4_time_evolution.html">4_time_evolution</a>
 &ndash; Tags:
      <a href="//nicolovaligi.com/tag/robotics.html">robotics</a>,      <a href="//nicolovaligi.com/tag/perception.html">perception</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Nicolò Valigi. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme originally by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>